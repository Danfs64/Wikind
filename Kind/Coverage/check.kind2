use Kind.Coverage as Cover

#derive[match]
type Result (a: Type) {
    ok (value: a)
    none
    bottom
}

Result.from_maybe <a> (m: Maybe a) : Result a
Result.from_maybe (Maybe.some x) = Result.ok x
Result.from_maybe Maybe.none = Result.bottom

#inline
Unsafe.coerce (n: _) : _
Unsafe.coerce n = n

Maybe.unsafe <t> (n : Maybe t) : t
Maybe.unsafe (Maybe.some n) = n

Cover/check.problem (problem: Cover/Problem) : Kind.Checker Cover/CaseTree
Cover/check.problem problem =
    do Kind.Checker {
        if Cover/Problem.is_empty problem {
            Kind.Checker.pure (Cover/CaseTree.uncovered)
        } else {
            if Cover/Problem.is_solved problem {
                Kind.Checker.pure Cover/CaseTree.done
            } else {
                Cover/Problem.intro problem
            }
        }
    }

Cover/check (function_id: Kind.Name): Kind.Checker Unit
Cover/check fnid =
    do Kind.Checker {
        let rules   = Kind.Axiom.RuleOf fnid
        let type    = Kind.Axiom.TypeOf fnid
        let problem = Cover/Problem.new type (rows = List.map rules (x => Cover/Row.new x []))
        ask tree    = Cover/check.problem problem
        return Unit.new
    }
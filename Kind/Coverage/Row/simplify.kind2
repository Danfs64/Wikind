Kind.Coverage.Row.simplify.go_finish
    (row: Zipper Kind.Coverage.Constraint)
    (zipper: Zipper Kind.Coverage.Constraint)
    (res: Result (List Kind.Coverage.Constraint))
    : Kind.Checker (Maybe (Zipper Kind.Coverage.Constraint))

Kind.Coverage.Row.simplify.go_finish row zipper (Result.ok value) = Kind.Coverage.Row.simplify.go (HVM.log "!" (Zipper.add_mass zipper value))
Kind.Coverage.Row.simplify.go_finish row zipper Result.none       = Kind.Coverage.Row.simplify.go (Zipper.move row)
Kind.Coverage.Row.simplify.go_finish row zipper Result.bottom     = Kind.Checker.pure Maybe.none

Kind.Coverage.Row.simplify.go (row: Zipper Kind.Coverage.Constraint) : Kind.Checker (Maybe (Zipper Kind.Coverage.Constraint))
Kind.Coverage.Row.simplify.go row =
    if Zipper.is_at_the_end row {
        Kind.Checker.pure (Maybe.pure row)
    } else {
        match Maybe res = (Zipper.remove row) {
            some =>
                do Kind.Checker {
                    let Pair.new (fst = constraint) (snd = zipper) = res.value
                    ask res = Kind.Coverage.Constraint.simplify constraint
                    Kind.Coverage.Row.simplify.go_finish row zipper res
                }
            none =>
                Kind.Checker.pure (Maybe.pure row)
        }
    }

Kind.Coverage.Row.simplify (row: Kind.Coverage.Row) : Kind.Checker (Maybe Kind.Coverage.Row)
Kind.Coverage.Row.simplify (Kind.Coverage.Row.new ty rows) =
    do Kind.Checker {
        ask res = Kind.Coverage.Row.simplify.go (Zipper.from_list rows)
        return Maybe.map (rows => Kind.Coverage.Row.new ty (Zipper.to_list rows)) res
    }
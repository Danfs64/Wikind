
Kind.Coverage.Constraint.simplify.go (ls: (List (Pair Kind.Term Kind.Term))) (constr_ty: Kind.Term) (constraint_ty: Kind.Term) : List Kind.Coverage.Constraint
Kind.Coverage.Constraint.simplify.go List.nil other constraint_ty = List.nil

Kind.Coverage.Constraint.simplify.go (List.cons arg xs) (Kind.Term.all orig name typ body) constraint_ty =
    let x = Kind.Coverage.Constraint.new (Pair.fst arg) (Pair.snd arg) typ
    List.cons x (Kind.Coverage.Constraint.simplify.go xs (body (Pair.fst arg)) constraint_ty)

Kind.Coverage.Constraint.simplify.go (List.cons arg xs) _ _ = List.nil

Kind.Coverage.Constraint.simplify (kd: Kind.Coverage.Constraint) : Kind.Checker (Result (List Kind.Coverage.Constraint))
Kind.Coverage.Constraint.simplify (Kind.Coverage.Constraint.new left (Kind.Term.var orig name idx) ty) =
    do Kind.Checker {
        ask is_equal = Kind.Checker.local (Kind.Checker.equal left (Kind.Term.var orig name idx))
        Kind.Checker.pure (Result.ok List.nil)
    }

Kind.Coverage.Constraint.simplify (Kind.Coverage.Constraint.new (Kind.Term.var orig name idx) right ty) =
    do Kind.Checker {
        ask values = Kind.Checker.find (List Kind.Term) idx List.nil (n => t => v => v)
        if List.is_nil values {
            do Kind.Checker {
                Kind.Checker.pure (Result.ok List.nil)
            }
        } else {
            do Kind.Checker {
                let res = (do Maybe {
                    ask value  = List.head values
                    ask name   = Kind.Coverage.get_name right
                    ask pairs  = Kind.Coverage.get_pairs value right
                    let ctr_ty = Kind.Axiom.TypeOf name
                    return Kind.Coverage.Constraint.simplify.go pairs ctr_ty ty
                })
                match Maybe res {
                    some => do Kind.Checker {
                        ask typ = Kind.Checker.infer (Kind.Term.var orig name idx)
                        return Result.ok res.value
                    }
                    none => Kind.Checker.pure Result.bottom
                }
            }
        }
    }

Kind.Coverage.Constraint.simplify (Kind.Coverage.Constraint.new left right ty) =
    do Kind.Checker {
        ask is_equal = Kind.Checker.equal left right
        if is_equal {
            Kind.Checker.pure Result.none
        } else {
            Kind.Checker.pure Result.bottom
        }
    }
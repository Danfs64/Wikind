use Apps.Kind.SyntaxTree.Sugared.ToCore as ToCore
use Apps.Kind.SyntaxTree.Sugared as Sugared
use Apps.Kind.SyntaxTree.Core as Core
use Data.Maybe as Maybe

ToCore/pattern (pat: Sugared/Pattern) : ToCore/ (Maybe/ Core/Term)

ToCore/pattern (Sugared/Pattern.var range name) =
  ToCore/pure (Maybe/some (Core/Term.var range name))

ToCore/pattern (Sugared/Pattern.ctr range name args) =

ToCore/pattern (Sugared/Pattern.u60 range val) =
  ToCore/pure (Maybe/some (Core/Term.num_u60 range val))

ToCore/pattern (Sugared/Pattern.u120 range val) = do ToCore/ {
  let has_u120 = ToCore/has_sugar Sugar/u120
  return do Maybe/ {
    has_u120
    return Term/make_u120 val
  }
}

ToCore/pattern (Sugared/Pattern.pair range fst snd) = do ToCore/ {
  ask has_sigma = ToCore/has_sugar Sugar/sigma
  ask fst = ToCore/pattern fst
  ask snd = ToCore/pattern snd
  return do Maybe/ {
    has_sigma
    ask fst = fst
    ask snd = snd
    return Core/Term range fst snd
  }
}

ToCore/pattern (Sugared/Pattern.list range args) = do ToCore/ {
  ask has_list = ToCore/has_sugar Sugar/list
  ask args = ToCore/list args (arg => ToCore/pattern arg)
  let list = do Maybe/ {
    has_list
    ask args = args  // list core/term
    return ToCore/make_list range args
  }
  (state: ToCore/State) => Maybe.map ((a: ToCore/) => a state) list
}

ToCore/pattern (Sugared/Pattern.string range val) = do ToCore/ {
  ask has_list = ToCore/has_sugar Sugar/string
  let string = ToCore/make_string range val
  return do Maybe/ {
    has_list
    return string
  }
}

ToCore/pattern (Sugared/Pattern.char range val) =
  ToCore/pure (Maybe/some (Core/Term.num_u60 range high))

ToCore/pattern (Sugared/Pattern.hole range) = do ToCore/ {
  ask var = ToCore/make_var range
  return Maybe/some var
}

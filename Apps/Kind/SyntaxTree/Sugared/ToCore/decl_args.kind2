use Apps.Kind.SyntaxTree.Sugared.ToCore as ToCore
use Apps.Kind.SyntaxTree.Sugared.Declaration as Declaration
use Apps.Kind.SyntaxTree.Sugared.Declaration.Entry as Entry
use Apps.Kind.SyntaxTree.Sugared as Sugared
use Apps.Kind.SyntaxTree.Core as Core
use Data.Map as Map

ToCore/decl_args (decls: Map/ Declaration/) (i: Data.U60) (n_decls: Data.U60) : ToCore/ (Map/ Declaration/)
ToCore/decl_args decls i n_decls =
  let Pair/new (fst=decls) (snd=decl) = Map/take decls (- n_decls i)
  match Maybe/ decl with decls {
    some (val=decl) => do ToCore/ {
      ask decl = ToCore/decl_args.go decl i
      let decls = Map/set decls i decl
      ToCore/decl_args decls (- i 1) n_decls
    }
    // We fill decls sequentially so it has to exist. Use better data struct
    none => ToCore/decl_args decls (- i 1) n_decls
  }
ToCore/decl_args decls 0 n_decls = ToCore/pure decls


ToCore/decl_args.go (decl: Declaration/) (i: Data.U60) : ToCore/ Declaration/
ToCore/decl_args.go (Declaration/entry (Entry/new name args type rules range)) i =
  let Pair/new (fst=args) (snd=hiddens) = ToCore/decl_args.hidden_args args
  let Pair/new (fst=args) (snd=n_args) = List/got_length hiddens
  let Pair/new (fst=args) (snd=n_hiddens) = List/got_length (List/filter hiddens ((x: Data.Bool) => x))
  let entry = Entry/new name args type rules range
  let decl = Declaration/entry entry
  do ToCore/ {
    ToCore/add_decl_args i n_args n_hiddens
    return decl
  }

// ToCore/decl_args.go (Declaration/record record) i =
// ToCore/decl_args.go (Declaration/sum sum) i =

ToCore/decl_args.hidden_args (args: List/ Argument/) : Pair/ (List/ Argument/) (List/ Data.Bool)
ToCore/decl_args.hidden_args (List/cons (Argument/.new range name type hidden erased) args) =
  let arg = (Argument/.new range name type hidden erased)
  let Pair/new (fst=args) (snd=hiddens) = ToCore/decl_args.hidden_args args
  let args = List/cons arg args
  let hiddens = List/cons hidden hiddens
  Pair/new args hiddens
ToCore/decl_args.hidden_args (List/nil) = Pair/new [] []